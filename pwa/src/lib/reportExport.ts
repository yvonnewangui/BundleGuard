import { formatBytes, getAppDisplayName, formatDate } from './utils';

export interface ReportData {
  date: Date;
  network: 'mobile' | 'wifi' | 'all';
  bundleInfo?: {
    operator: string;
    type: string;
    totalBytes: number;
    usedBytes: number;
  };
  topApps: Array<{
    package: string;
    bytes: number;
  }>;
  totalUsage: number;
  likelyCauses: string[];
  recommendations: string[];
}

/**
 * Generate a text version of the report for copying/sharing
 */
export function generateTextReport(data: ReportData): string {
  const lines: string[] = [];
  
  lines.push('═══════════════════════════════════════');
  lines.push('        BUNDLEGUARD PROOF REPORT');
  lines.push('═══════════════════════════════════════');
  lines.push('');
  lines.push(`Date: ${formatDate(data.date)}`);
  lines.push(`Network: ${data.network === 'all' ? 'All Networks' : data.network.charAt(0).toUpperCase() + data.network.slice(1)}`);
  lines.push(`Total Usage: ${formatBytes(data.totalUsage)}`);
  lines.push('');
  
  if (data.bundleInfo) {
    lines.push('─── BUNDLE STATUS ───────────────────');
    lines.push(`Operator: ${data.bundleInfo.operator}`);
    lines.push(`Type: ${data.bundleInfo.type}`);
    lines.push(`Total: ${formatBytes(data.bundleInfo.totalBytes)}`);
    lines.push(`Used: ${formatBytes(data.bundleInfo.usedBytes)}`);
    lines.push(`Remaining: ${formatBytes(data.bundleInfo.totalBytes - data.bundleInfo.usedBytes)}`);
    lines.push('');
  }
  
  lines.push('─── TOP DATA CONSUMERS ──────────────');
  data.topApps.slice(0, 5).forEach((app, index) => {
    lines.push(`${index + 1}. ${getAppDisplayName(app.package)}: ${formatBytes(app.bytes)}`);
  });
  lines.push('');
  
  if (data.likelyCauses.length > 0) {
    lines.push('─── LIKELY CAUSES ───────────────────');
    data.likelyCauses.forEach((cause, index) => {
      lines.push(`• ${cause}`);
    });
    lines.push('');
  }
  
  if (data.recommendations.length > 0) {
    lines.push('─── RECOMMENDATIONS ─────────────────');
    data.recommendations.forEach((rec, index) => {
      lines.push(`• ${rec}`);
    });
    lines.push('');
  }
  
  lines.push('═══════════════════════════════════════');
  lines.push(`Generated by BundleGuard • ${formatDate(new Date())}`);
  lines.push('https://bundleguard.app');
  lines.push('═══════════════════════════════════════');
  
  return lines.join('\n');
}

/**
 * Generate HTML version of the report for image/PDF export
 */
export function generateHtmlReport(data: ReportData): string {
  return `
<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>BundleGuard Report - ${formatDate(data.date)}</title>
  <style>
    * { margin: 0; padding: 0; box-sizing: border-box; }
    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #f9fafb;
      padding: 20px;
    }
    .report {
      max-width: 400px;
      margin: 0 auto;
      background: white;
      border-radius: 16px;
      overflow: hidden;
      box-shadow: 0 4px 6px rgba(0,0,0,0.1);
    }
    .header {
      background: linear-gradient(135deg, #16a34a 0%, #22c55e 100%);
      color: white;
      padding: 24px;
    }
    .header-top {
      display: flex;
      justify-content: space-between;
      font-size: 12px;
      opacity: 0.9;
      margin-bottom: 8px;
    }
    .usage-amount {
      font-size: 32px;
      font-weight: bold;
      margin-bottom: 4px;
    }
    .network-type {
      font-size: 14px;
      opacity: 0.9;
    }
    .section {
      padding: 16px 24px;
      border-bottom: 1px solid #e5e7eb;
    }
    .section:last-child { border-bottom: none; }
    .section-title {
      font-size: 14px;
      font-weight: 600;
      color: #374151;
      margin-bottom: 12px;
      display: flex;
      align-items: center;
    }
    .section-title svg {
      margin-right: 8px;
    }
    .bundle-grid {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 8px;
      font-size: 14px;
    }
    .bundle-item label {
      color: #6b7280;
    }
    .bundle-item span {
      font-weight: 500;
      color: #111827;
      margin-left: 4px;
    }
    .app-row {
      display: flex;
      justify-content: space-between;
      align-items: center;
      padding: 8px 0;
      border-bottom: 1px solid #f3f4f6;
    }
    .app-row:last-child { border-bottom: none; }
    .app-info {
      display: flex;
      align-items: center;
    }
    .app-rank {
      width: 24px;
      height: 24px;
      background: #f3f4f6;
      border-radius: 50%;
      display: flex;
      align-items: center;
      justify-content: center;
      font-size: 12px;
      font-weight: 500;
      margin-right: 12px;
    }
    .app-name {
      font-size: 14px;
      color: #111827;
    }
    .app-usage {
      font-size: 14px;
      font-weight: 500;
      color: #111827;
    }
    .list-item {
      display: flex;
      align-items: flex-start;
      font-size: 13px;
      color: #4b5563;
      margin-bottom: 8px;
    }
    .list-item:last-child { margin-bottom: 0; }
    .bullet {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      margin-right: 10px;
      margin-top: 6px;
      flex-shrink: 0;
    }
    .bullet-orange { background: #fb923c; }
    .bullet-green { background: #22c55e; }
    .footer {
      text-align: center;
      padding: 16px;
      font-size: 11px;
      color: #9ca3af;
    }
    .qr-section {
      text-align: center;
      padding: 16px;
    }
    .qr-code {
      width: 100px;
      height: 100px;
      margin: 0 auto;
    }
  </style>
</head>
<body>
  <div class="report">
    <div class="header">
      <div class="header-top">
        <span>BundleGuard Report</span>
        <span>${formatDate(data.date)}</span>
      </div>
      <div class="usage-amount">${formatBytes(data.totalUsage)}</div>
      <div class="network-type">${data.network === 'all' ? 'All Networks' : data.network.charAt(0).toUpperCase() + data.network.slice(1)} Usage</div>
    </div>
    
    ${data.bundleInfo ? `
    <div class="section">
      <div class="section-title">Bundle Status</div>
      <div class="bundle-grid">
        <div class="bundle-item"><label>Operator:</label><span>${data.bundleInfo.operator}</span></div>
        <div class="bundle-item"><label>Type:</label><span>${data.bundleInfo.type}</span></div>
        <div class="bundle-item"><label>Total:</label><span>${formatBytes(data.bundleInfo.totalBytes)}</span></div>
        <div class="bundle-item"><label>Used:</label><span>${formatBytes(data.bundleInfo.usedBytes)}</span></div>
      </div>
    </div>
    ` : ''}
    
    <div class="section">
      <div class="section-title">Top Data Consumers</div>
      ${data.topApps.slice(0, 5).map((app, i) => `
        <div class="app-row">
          <div class="app-info">
            <div class="app-rank">${i + 1}</div>
            <div class="app-name">${getAppDisplayName(app.package)}</div>
          </div>
          <div class="app-usage">${formatBytes(app.bytes)}</div>
        </div>
      `).join('')}
    </div>
    
    ${data.likelyCauses.length > 0 ? `
    <div class="section">
      <div class="section-title">Likely Causes</div>
      ${data.likelyCauses.map(cause => `
        <div class="list-item">
          <div class="bullet bullet-orange"></div>
          <span>${cause}</span>
        </div>
      `).join('')}
    </div>
    ` : ''}
    
    ${data.recommendations.length > 0 ? `
    <div class="section">
      <div class="section-title">What To Do Next</div>
      ${data.recommendations.map(rec => `
        <div class="list-item">
          <div class="bullet bullet-green"></div>
          <span>${rec}</span>
        </div>
      `).join('')}
    </div>
    ` : ''}
    
    <div class="footer">
      Generated by BundleGuard • ${formatDate(new Date())}
    </div>
  </div>
</body>
</html>
  `;
}

/**
 * Copy report text to clipboard
 */
export async function copyReportToClipboard(data: ReportData): Promise<boolean> {
  try {
    const text = generateTextReport(data);
    await navigator.clipboard.writeText(text);
    return true;
  } catch (error) {
    console.error('Failed to copy to clipboard:', error);
    return false;
  }
}

/**
 * Share report using Web Share API
 */
export async function shareReport(data: ReportData): Promise<boolean> {
  const text = generateTextReport(data);
  const title = `BundleGuard Report - ${formatDate(data.date)}`;
  
  // Check if Web Share API is available
  if (navigator.share) {
    try {
      await navigator.share({
        title,
        text,
      });
      return true;
    } catch (error) {
      // User cancelled or share failed
      if ((error as Error).name !== 'AbortError') {
        console.error('Share failed:', error);
      }
      return false;
    }
  }
  
  // Fallback: copy to clipboard
  return copyReportToClipboard(data);
}

/**
 * Share report as image using html2canvas
 */
export async function shareReportAsImage(element: HTMLElement, data: ReportData): Promise<boolean> {
  try {
    // Dynamically import html2canvas
    const html2canvas = (await import('html2canvas')).default;
    
    const canvas = await html2canvas(element, {
      backgroundColor: '#ffffff',
      scale: 2, // Higher quality
      logging: false,
    });
    
    const blob = await new Promise<Blob | null>((resolve) => {
      canvas.toBlob(resolve, 'image/png', 1.0);
    });
    
    if (!blob) {
      throw new Error('Failed to create image blob');
    }
    
    const file = new File([blob], `bundleguard-report-${Date.now()}.png`, { type: 'image/png' });
    
    // Try Web Share API with file
    if (navigator.share && navigator.canShare && navigator.canShare({ files: [file] })) {
      await navigator.share({
        title: `BundleGuard Report - ${formatDate(data.date)}`,
        files: [file],
      });
      return true;
    }
    
    // Fallback: download the image
    downloadBlob(blob, `bundleguard-report-${formatDate(data.date).replace(/\//g, '-')}.png`);
    return true;
  } catch (error) {
    console.error('Failed to share as image:', error);
    return false;
  }
}

/**
 * Save report as PDF
 */
export async function saveReportAsPdf(data: ReportData): Promise<boolean> {
  try {
    // Create a temporary iframe to render the HTML
    const html = generateHtmlReport(data);
    const blob = new Blob([html], { type: 'text/html' });
    const url = URL.createObjectURL(blob);
    
    // Open print dialog which allows saving as PDF
    const printWindow = window.open(url, '_blank');
    if (printWindow) {
      printWindow.onload = () => {
        printWindow.print();
        URL.revokeObjectURL(url);
      };
      return true;
    }
    
    URL.revokeObjectURL(url);
    return false;
  } catch (error) {
    console.error('Failed to save as PDF:', error);
    return false;
  }
}

/**
 * Save report as image (PNG)
 */
export async function saveReportAsImage(element: HTMLElement, data: ReportData): Promise<boolean> {
  try {
    const html2canvas = (await import('html2canvas')).default;
    
    const canvas = await html2canvas(element, {
      backgroundColor: '#ffffff',
      scale: 2,
      logging: false,
    });
    
    const blob = await new Promise<Blob | null>((resolve) => {
      canvas.toBlob(resolve, 'image/png', 1.0);
    });
    
    if (!blob) {
      throw new Error('Failed to create image blob');
    }
    
    downloadBlob(blob, `bundleguard-report-${formatDate(data.date).replace(/\//g, '-')}.png`);
    return true;
  } catch (error) {
    console.error('Failed to save as image:', error);
    return false;
  }
}

/**
 * Save report as text file
 */
export function saveReportAsText(data: ReportData): boolean {
  try {
    const text = generateTextReport(data);
    const blob = new Blob([text], { type: 'text/plain' });
    downloadBlob(blob, `bundleguard-report-${formatDate(data.date).replace(/\//g, '-')}.txt`);
    return true;
  } catch (error) {
    console.error('Failed to save as text:', error);
    return false;
  }
}

/**
 * Save report as JSON (for data export)
 */
export function saveReportAsJson(data: ReportData): boolean {
  try {
    const exportData = {
      ...data,
      generatedAt: new Date().toISOString(),
      version: '1.0',
      source: 'BundleGuard',
    };
    const json = JSON.stringify(exportData, null, 2);
    const blob = new Blob([json], { type: 'application/json' });
    downloadBlob(blob, `bundleguard-report-${formatDate(data.date).replace(/\//g, '-')}.json`);
    return true;
  } catch (error) {
    console.error('Failed to save as JSON:', error);
    return false;
  }
}

/**
 * Helper to download a blob
 */
function downloadBlob(blob: Blob, filename: string) {
  const url = URL.createObjectURL(blob);
  const a = document.createElement('a');
  a.href = url;
  a.download = filename;
  document.body.appendChild(a);
  a.click();
  document.body.removeChild(a);
  URL.revokeObjectURL(url);
}

/**
 * Generate QR code data URL for the report
 */
export async function generateReportQrCode(data: ReportData): Promise<string | null> {
  try {
    const QRCode = (await import('qrcode')).default;
    
    // Create a compact summary for QR code
    const summary = {
      d: formatDate(data.date),
      u: formatBytes(data.totalUsage),
      n: data.network,
      t: data.topApps.slice(0, 3).map(a => ({
        n: getAppDisplayName(a.package).substring(0, 10),
        b: formatBytes(a.bytes)
      })),
      s: 'BundleGuard'
    };
    
    const qrDataUrl = await QRCode.toDataURL(JSON.stringify(summary), {
      width: 200,
      margin: 2,
      color: {
        dark: '#16a34a',
        light: '#ffffff'
      }
    });
    
    return qrDataUrl;
  } catch (error) {
    console.error('Failed to generate QR code:', error);
    return null;
  }
}
